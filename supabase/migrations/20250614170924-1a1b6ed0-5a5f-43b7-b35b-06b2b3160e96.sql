
-- Add a balance column to the profiles table
ALTER TABLE public.profiles
ADD COLUMN balance NUMERIC(10, 2) NOT NULL DEFAULT 0.00;

-- Create a table for upvote orders
CREATE TABLE public.upvote_orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  link TEXT NOT NULL,
  quantity INT NOT NULL,
  service INT NOT NULL,
  speed NUMERIC NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  external_order_id TEXT
);

-- Enable RLS for upvote_orders
ALTER TABLE public.upvote_orders ENABLE ROW LEVEL SECURITY;

-- Policies for upvote_orders
CREATE POLICY "Users can view their own upvote orders"
  ON public.upvote_orders FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own upvote orders"
  ON public.upvote_orders FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own upvote orders"
  ON public.upvote_orders FOR UPDATE
  USING (auth.uid() = user_id);

-- Create a function to handle placing an upvote order atomically
CREATE OR REPLACE FUNCTION place_upvote_order(
    order_link text,
    order_quantity int,
    order_service int,
    order_speed numeric
)
RETURNS TABLE (order_id bigint, error_message text)
LANGUAGE plpgsql
AS $$
DECLARE
    current_user_id uuid := auth.uid();
    cost numeric;
    user_balance numeric;
    new_order_id bigint;
    service_description text;
BEGIN
    -- Calculate cost and description based on service type
    IF order_service = 1 THEN -- Post upvotes
        cost := order_quantity * 0.10;
        service_description := 'Post upvotes';
    ELSIF order_service = 2 THEN -- Post downvotes
        cost := order_quantity * 0.10;
        service_description := 'Post downvotes';
    ELSIF order_service = 3 THEN -- Comment upvotes
        cost := order_quantity * 0.08;
        service_description := 'Comment upvotes';
    ELSIF order_service = 4 THEN -- Comment downvotes
        cost := order_quantity * 0.08;
        service_description := 'Comment downvotes';
    ELSE
        RETURN QUERY SELECT null::bigint, 'Invalid service type.'::text;
        RETURN;
    END IF;

    -- Check user balance
    SELECT balance INTO user_balance FROM public.profiles WHERE id = current_user_id;

    IF user_balance IS NULL OR user_balance < cost THEN
        RETURN QUERY SELECT null::bigint, 'Insufficient balance. Please add funds.'::text;
        RETURN;
    END IF;

    -- Insert new order
    INSERT INTO public.upvote_orders (user_id, link, quantity, service, speed)
    VALUES (current_user_id, order_link, order_quantity, order_service, order_speed)
    RETURNING id INTO new_order_id;

    -- Insert transaction
    INSERT INTO public.transactions (user_id, type, amount, description, status)
    VALUES (current_user_id, 'purchase', -cost, 'Purchase: ' || order_quantity || ' ' || service_description || ' for order #' || new_order_id, 'completed');

    -- Update user balance
    UPDATE public.profiles
    SET balance = balance - cost
    WHERE id = current_user_id;
    
    RETURN QUERY SELECT new_order_id, null::text;
END;
$$;
