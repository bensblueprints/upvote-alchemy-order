-- ================================================
-- UPVOTE ALCHEMY DATABASE SETUP SCRIPT
-- ================================================
-- Run this script in your Supabase SQL Editor to set up the complete database schema

-- 1. Create profiles table with balance and admin flag
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now(),
    email text NOT NULL,
    balance numeric(10, 2) NOT NULL DEFAULT 0.00,
    is_admin boolean DEFAULT false
);

-- Enable RLS on profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Users can view own profile" ON public.profiles 
    FOR SELECT USING (auth.uid() = id);
    
CREATE POLICY "Users can update own profile" ON public.profiles 
    FOR UPDATE USING (auth.uid() = id);

-- 2. Create transactions table
CREATE TABLE public.transactions (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type text NOT NULL,
    amount numeric NOT NULL,
    description text,
    status text NOT NULL DEFAULT 'completed',
    upvote_order_id bigint
);

-- Enable RLS on transactions
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- 3. Create upvote_orders table
CREATE TABLE public.upvote_orders (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    link text NOT NULL,
    quantity int NOT NULL,
    service int NOT NULL,
    speed numeric NOT NULL,
    status text NOT NULL DEFAULT 'pending',
    external_order_id text,
    error_message text
);

-- Enable RLS on upvote_orders
ALTER TABLE public.upvote_orders ENABLE ROW LEVEL SECURITY;

-- Add foreign key constraint for transactions
ALTER TABLE public.transactions
ADD CONSTRAINT fk_upvote_order
FOREIGN KEY (upvote_order_id)
REFERENCES public.upvote_orders(id)
ON DELETE SET NULL;

-- 4. Create reddit_accounts table
CREATE TABLE public.reddit_accounts (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    username text NOT NULL,
    password text NOT NULL,
    email text NOT NULL,
    email_password text NOT NULL,
    post_karma integer NOT NULL DEFAULT 0,
    comment_karma integer NOT NULL DEFAULT 0,
    total_karma integer GENERATED ALWAYS AS (post_karma + comment_karma) STORED,
    account_age_years integer,
    profile_url text,
    status text NOT NULL DEFAULT 'available' CHECK (status IN ('available', 'sold')),
    buy_price numeric NOT NULL DEFAULT 0,
    sell_price numeric NOT NULL DEFAULT 0,
    created_by_admin_id uuid REFERENCES public.profiles(id),
    sold_to_user_id uuid REFERENCES public.profiles(id),
    sold_at timestamp with time zone
);

-- Enable RLS on reddit_accounts
ALTER TABLE public.reddit_accounts ENABLE ROW LEVEL SECURITY;

-- 5. Create orders table (for Stripe integration)
CREATE TABLE public.orders (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    status text,
    amount_total numeric,
    currency text,
    stripe_session_id text
);

-- Enable RLS on orders
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

-- 6. Create audit_logs table
CREATE TABLE public.audit_logs (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    user_id uuid REFERENCES public.profiles(id),
    action text NOT NULL,
    resource_type text NOT NULL,
    resource_id text,
    details jsonb,
    ip_address inet
);

-- Enable RLS on audit_logs
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- 7. Create settings table for API keys
CREATE TABLE public.settings (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    key text NOT NULL UNIQUE,
    value text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Enable RLS on settings
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;

-- ================================================
-- RLS POLICIES
-- ================================================

-- Upvote orders policies
CREATE POLICY "Users can view their own upvote orders" ON public.upvote_orders 
    FOR SELECT USING (auth.uid() = user_id);
    
CREATE POLICY "Users can insert their own upvote orders" ON public.upvote_orders 
    FOR INSERT WITH CHECK (auth.uid() = user_id);
    
CREATE POLICY "Users can update their own upvote orders" ON public.upvote_orders 
    FOR UPDATE USING (auth.uid() = user_id);

-- Transactions policies
CREATE POLICY "Users can view their own transactions only" ON public.transactions 
    FOR SELECT USING (auth.uid() = user_id);
    
CREATE POLICY "Admins can view all transactions" ON public.transactions 
    FOR SELECT USING ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = TRUE);

-- Reddit accounts policies
CREATE POLICY "Admins can manage all reddit accounts" ON public.reddit_accounts 
    FOR ALL USING ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = TRUE);
    
CREATE POLICY "Users can view available accounts for purchase" ON public.reddit_accounts 
    FOR SELECT USING (status = 'available');
    
CREATE POLICY "Users can view their purchased accounts" ON public.reddit_accounts 
    FOR SELECT USING (sold_to_user_id = auth.uid() AND status = 'sold');

-- Orders policies
CREATE POLICY "Users can view their own orders" ON public.orders 
    FOR SELECT USING (auth.uid() = user_id);
    
CREATE POLICY "Users can insert their own orders" ON public.orders 
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Audit logs policies
CREATE POLICY "Only admins can view audit logs" ON public.audit_logs 
    FOR SELECT USING ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = TRUE);

-- Settings policies
CREATE POLICY "Only admins can manage settings" ON public.settings 
    FOR ALL USING ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = TRUE);

-- ================================================
-- FUNCTIONS
-- ================================================

-- Function to place upvote orders with balance checking
CREATE OR REPLACE FUNCTION public.place_upvote_order(
    order_link text,
    order_quantity int,
    order_service int,
    order_speed numeric
)
RETURNS TABLE (order_id bigint, error_message text)
LANGUAGE plpgsql
AS $$
DECLARE
    current_user_id uuid := auth.uid();
    cost numeric;
    user_balance numeric;
    new_order_id bigint;
    service_description text;
    post_vote_price numeric;
    comment_vote_price numeric;
BEGIN
    -- Get user balance
    SELECT balance INTO user_balance FROM public.profiles WHERE id = current_user_id;

    -- Determine pricing tier based on user's balance
    IF user_balance >= 1000 THEN -- Elite
        post_vote_price := 0.04;
    ELSIF user_balance >= 750 THEN -- Pro
        post_vote_price := 0.06;
    ELSIF user_balance >= 250 THEN -- Standard
        post_vote_price := 0.08;
    ELSIF user_balance >= 100 THEN -- Basic
        post_vote_price := 0.10;
    ELSIF user_balance >= 15 THEN -- Starter
        post_vote_price := 0.20;
    ELSE -- Default for balances < $15
        post_vote_price := 0.20;
    END IF;

    -- Comment votes are 80% of post vote price
    comment_vote_price := post_vote_price * 0.8;

    -- Calculate cost and description based on service type
    IF order_service = 1 THEN cost := order_quantity * post_vote_price; service_description := 'Post upvotes';
    ELSIF order_service = 2 THEN cost := order_quantity * post_vote_price; service_description := 'Post downvotes';
    ELSIF order_service = 3 THEN cost := order_quantity * comment_vote_price; service_description := 'Comment upvotes';
    ELSIF order_service = 4 THEN cost := order_quantity * comment_vote_price; service_description := 'Comment downvotes';
    ELSE
        RETURN QUERY SELECT null::bigint, 'Invalid service type.'::text;
        RETURN;
    END IF;

    -- Check user balance
    IF user_balance IS NULL OR user_balance < cost THEN
        RETURN QUERY SELECT null::bigint, 'Insufficient balance. Please add funds.'::text;
        RETURN;
    END IF;

    -- Insert new order
    INSERT INTO public.upvote_orders (user_id, link, quantity, service, speed)
    VALUES (current_user_id, order_link, order_quantity, order_service, order_speed)
    RETURNING id INTO new_order_id;

    -- Insert transaction
    INSERT INTO public.transactions (user_id, type, amount, description, status, upvote_order_id)
    VALUES (current_user_id, 'purchase', -cost, 'Purchase: ' || order_quantity || ' ' || service_description || ' for order #' || new_order_id, 'completed', new_order_id);

    -- Update user balance
    UPDATE public.profiles SET balance = balance - cost WHERE id = current_user_id;
    
    RETURN QUERY SELECT new_order_id, null::text;
END;
$$;

-- Function to purchase Reddit accounts
CREATE OR REPLACE FUNCTION public.purchase_reddit_account(account_id uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    current_user_id uuid := auth.uid();
    account_to_purchase public.reddit_accounts;
    user_balance numeric;
BEGIN
    -- Check if user is authenticated
    IF current_user_id IS NULL THEN
        RETURN 'Error: Authentication required.';
    END IF;

    -- Get account details and lock the row
    SELECT * INTO account_to_purchase 
    FROM public.reddit_accounts 
    WHERE id = account_id FOR UPDATE;

    -- Check if account exists
    IF account_to_purchase.id IS NULL THEN
        RETURN 'Error: Account not found.';
    END IF;

    -- Check if account is available
    IF account_to_purchase.status <> 'available' THEN
        RETURN 'Error: Account is not available for purchase.';
    END IF;

    -- Get user balance
    SELECT balance INTO user_balance 
    FROM public.profiles 
    WHERE id = current_user_id FOR UPDATE;

    -- Check if user has sufficient balance
    IF user_balance IS NULL OR user_balance < account_to_purchase.sell_price THEN
        RETURN 'Error: Insufficient balance. Please add funds to your account.';
    END IF;
    
    -- Update user balance
    UPDATE public.profiles SET balance = balance - account_to_purchase.sell_price WHERE id = current_user_id;
    
    -- Update account status
    UPDATE public.reddit_accounts
    SET status = 'sold', sold_to_user_id = current_user_id, sold_at = now()
    WHERE id = account_id;

    -- Create transaction record
    INSERT INTO public.transactions (user_id, type, amount, description, status)
    VALUES (current_user_id, 'reddit_account_purchase', -account_to_purchase.sell_price, 'Purchased Reddit account: ' || account_to_purchase.username, 'completed');

    RETURN 'Success: Account purchased successfully.';
END;
$$;

-- Function to refund orders
CREATE OR REPLACE FUNCTION public.refund_order(target_order_id bigint)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    order_record public.upvote_orders;
    refund_amount numeric;
    original_transaction public.transactions;
BEGIN
    -- Get the order details
    SELECT * INTO order_record FROM public.upvote_orders WHERE id = target_order_id;
    
    IF order_record.id IS NULL THEN
        RETURN 'Error: Order not found.';
    END IF;
    
    -- Get the original transaction
    SELECT * INTO original_transaction 
    FROM public.transactions 
    WHERE upvote_order_id = target_order_id AND type = 'purchase'
    ORDER BY created_at DESC LIMIT 1;
    
    IF original_transaction.id IS NULL THEN
        RETURN 'Error: Original transaction not found.';
    END IF;
    
    refund_amount := -original_transaction.amount; -- Make it positive
    
    -- Add refund to user balance
    UPDATE public.profiles 
    SET balance = balance + refund_amount 
    WHERE id = order_record.user_id;
    
    -- Create refund transaction
    INSERT INTO public.transactions (user_id, type, amount, description, status, upvote_order_id)
    VALUES (order_record.user_id, 'refund', refund_amount, 'Refund for order #' || target_order_id, 'completed', target_order_id);
    
    RETURN 'Success: Refund of $' || refund_amount || ' has been processed.';
END;
$$;

-- Function to log audit events
CREATE OR REPLACE FUNCTION public.log_audit_event(
    p_action text,
    p_resource_type text,
    p_resource_id text DEFAULT NULL,
    p_details jsonb DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO public.audit_logs (user_id, action, resource_type, resource_id, details)
    VALUES (auth.uid(), p_action, p_resource_type, p_resource_id, p_details);
END;
$$;

-- Function to validate password strength
CREATE OR REPLACE FUNCTION public.validate_password_strength(password text)
RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    -- Check minimum length (8 characters)
    IF length(password) < 8 THEN RETURN FALSE; END IF;
    
    -- Check for at least one uppercase letter
    IF password !~ '[A-Z]' THEN RETURN FALSE; END IF;
    
    -- Check for at least one lowercase letter
    IF password !~ '[a-z]' THEN RETURN FALSE; END IF;
    
    -- Check for at least one number
    IF password !~ '[0-9]' THEN RETURN FALSE; END IF;
    
    RETURN TRUE;
END;
$$;

-- ================================================
-- TRIGGERS
-- ================================================

-- Trigger to automatically create profile when user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
    INSERT INTO public.profiles (id, email)
    VALUES (new.id, new.email);
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- ================================================
-- COMPLETION MESSAGE
-- ================================================

DO $$
BEGIN
    RAISE NOTICE 'Database setup completed successfully!';
    RAISE NOTICE 'You can now update your .env.local file with your Supabase credentials.';
END $$; 